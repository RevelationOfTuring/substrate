## 5.Rust进阶（续）

![image-20210109180833893](assets/image-20210109180833893.png)

宏是一种元编程，并不是Rust特有的。Java中的反射也是一种元编程。

![image-20210109180945475](assets/image-20210109180945475.png)

DSL是否会给初学者造成一些负担呢？最开始看的话是这个样子，但是如果没有这套DSL，可能需要你自己去实现很多底层的东西，反倒是容易让开发者直接放弃。

通过这套DSL使得开发者不用再去关注底层的实现（比如数据库，P2P，密码学等），只需要开发者实现自己的业务逻辑即可。

![image-20210109182745725](assets/image-20210109182745725.png)

runtime即状态转换函数，由交易触发。

![image-20210109182830741](assets/image-20210109182830741.png)

这样你的开发过程就像是在作画，每个pallet就是你的作画工具。

常用pallets：

- 资产相关：assets和balances
- 共识相关：babe和grandpa
- 治理相关：collective和democracy

![image-20210109183138189](assets/image-20210109183138189.png)

**decl_storage**

![image-20210109183235889](assets/image-20210109183235889.png)

例子：

![image-20210109184305362](assets/image-20210109184305362.png)

首先定义了一个trait Trait。该trait是继承自system::Trait。其内部定义了一个关联类型Event，该类型有两个约束：1. 可以从模块内部的Event转换成这里面的关联类型Event；2.可以变成system模块中的Event。

decl_storage!宏中定义了该pallet存储的数据结构。TemplateModule是给出的一个名称，用于和其他模块进行隔离。其中定义了一个存储单元Something，其类型是`Option<u32>`。这里还定义了一个可选的get函数something（通过fn+函数名定义函数）。

注：除了定义`Option<u32>`这样的单值类型外，还可以定义映射类型和双键映射类型，后面会去介绍。

**decl_module**

![image-20210109184512981](assets/image-20210109184512981.png)

交易在substrate中也被称作extrinsic。这些交易能被实现，是因为同时定义了对应的可调用函数。

例子：

![image-20210109184744978](assets/image-20210109184744978.png)

在decl_module宏中，定义了一个结构体Module，以及一个enum Call并给出了一个类型的约束origin。该约束origin的类型是由Module的泛型T提供的Origin约束。这是因为T本身绑定的Trait约束中并不包含Origin约束，但是其是继承自system::Trait，所以Origin约束的类型也是来自于system模块。

如果我们在可调用函数中使用到错误信息的话，我们需要对错误类型进行绑定：`type Error = Error<T>;`

如果可调用函数里需要触发事件的话，需要去填写这样一个函数声明：`fn deposit_event() = default;`

真正的可调用函数逻辑是在`pub fn do_something`被定义。其上面的`#[weight = 10_00]`是用来表示可调用函数的权重，具体权重的定义会在后面的课程中介绍。

do_something函数包含两个参数：1.上述的约束类型origin，即`T::Origin`；2.something，其类型为u32。

所有的调用函数的返回结果都是一个DispatchResult类型。DispatchResult其实是Rust中的Result的一个类型别名：

```rust
pub type DispatchResult = Result<(), sp_runtime::DispatchError>;
```

如果是Error则返回DispatchError类型的错误，如果是Ok则返回空tuple`()`。

看一下业务逻辑：

```rust
			// 将something的值存入存储单元Something中
			Something::put(something);

			// 触发SomethingStored这样一个事件
			Self::deposit_event(RawEvent::SomethingStored(something, who));
			// Return a successful DispatchResult
			Ok(())
```

下面来看一下另一个可调用函数的例子：

![image-20210109191439987](assets/image-20210109191439987.png)

具体逻辑：

```rust
		/// An example dispatchable that may throw a custom error.
		#[weight = 10_000]
		pub fn cause_error(origin) -> dispatch::DispatchResult {
			// -- snip --

			// 通过get函数来获取存储单元Something中的值
			match Something::get() {
				// 如果存储单元返回值为None，返回Error的类型为自定义（在decl_error宏中定义 ）的Error类型NoneValue
				None => Err(Error::<T>::NoneValue)?,
        // 入错存储单元中有值，值存储在old中
				Some(old) => {
					// 对old进行安全的+1操作。如果检查出现异常，则返回自定义的StorageOverflow类型的Error
          // 注：?在Rust中表示对Result类型解包，如果是Error直接返回，如果不是Error则取出其中Ok包裹的值
					let new = old.checked_add(1).ok_or(Error::<T>::StorageOverflow)?;
					// 将new报错到Something的存储单元中
					Something::put(new);
					Ok(())
				},
			}
		}
```

**保留函数**

![image-20210109193227909](assets/image-20210109193227909.png)

on_initialize：会在每个区块的开头执行，比如在每个区块中检查定时器队列中有无待执行的任务。如果有的话会首先去执行

on_finalize：同上，但是是区块结束时执行

offchain_worker：链外工作机，用来执行计算复杂度较高或需要与外部数据源交互的使用场景